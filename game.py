import time

import word
import tk_layout
import tkinter as tk
import threading
from functools import partial
import keyboard


class Game:
    LIFE = 3
    DEFAULT_TIME = 10
    NB_WORD = 10
    timer = DEFAULT_TIME

    def __init__(self, root, nWord=NB_WORD, nLife=LIFE):
        self.nWord = nWord
        self.nLife = nLife  # Initial life
        self.cLife = self.nLife  # Current life
        self.totalTime = 0
        self.wordTime = 0
        # Stock Graphic_Element - [0:Lives_count, 1:Word_count, 2:Clock, 3:Text_label]
        self.GE = []
        self.stop_thread = threading.Event()
        self.root = root

    #  --------------------------------Custom layout creation-----------------------------------------

    #  Set up the home menu layout
    def layout_home(self):
        tk_layout.add_frame(self.root)
        tk_layout.add_title(self.root, 'Speed Typer Game')
        tk_layout.add_subtitle(self.root, 'Type words the fastest you can !')
        tk_layout.add_frame(self.root)
        tk_layout.add_play('Play !', self.playing)
        tk_layout.add_frame(self.root)

    # Set up the end game layout
    def layout_end(self, root, time):
        tk_layout.remove_all_w(root)
        tk_layout.add_frame(root)
        if time == -1:
            tk_layout.add_subtitle(root, f'You exit the game !')
        elif time != -100:
            tk_layout.add_subtitle(root, f'You finished in {time} seconds !')
        else:
            tk_layout.add_subtitle(root, f'No more lives, you lost !')
        tk_layout.add_frame(root)
        tk_layout.add_play('Play again !', self.playing)

        # Ensure listener stops when the Tkinter window is closed
        # root.protocol("WM_DELETE_WINDOW", app.stop_listener)
        root.mainloop()  # the remove_w function also remove the mainloop parameter

    #  Set up the playing menu layout
    def layout_game(self, countdown=DEFAULT_TIME):
        tk_layout.remove_all_w(self.root)
        tk_layout.add_frame(self.root)
        tk_layout.add_frame(self.root)
        lives_count = tk_layout.add_subtitle(self.root, f'Lives :{self.nLife}/{self.nLife}')
        word_count = tk_layout.add_subtitle(self.root, 'Words :1/5')
        tk_layout.add_frame(self.root)
        clock = tk.Label(self.root, text=countdown)
        clock.pack()
        text = tk_layout.add_text(self.root, '', 0)
        text.pack()
        return lives_count, word_count, clock, text

    def countdown(self, parent, label, duration=DEFAULT_TIME):
        # stop_thread.clear()
        if not self.stop_thread.is_set():
            duration -= 1
            label.config(text=str(duration))
            parent.after(1000, partial(self.countdown, parent, label, duration))
        return True

        # -------------------------Sub class - Word to guess ---------------------------

    class word_to_guess:
        def __init__(self, root, GE, toTyped):
            self.root = root
            self.GE = GE
            self.word = toTyped
            self.keys_pressed = ''
            self.end = False

    def create_WTG(self, root, GE, toType):
        WTG = self.word_to_guess(root, GE, toType)

    def playing(self):
        # -------------------------Game Init---------------------------
        # Prerequisite
        game_list = word.extract_json_word(5, 'words/words_dictionary.json')

        # Get the widget generated by the Layout_game function
        layout_return = self.layout_game(self.root)
        # Graphic_Element - [0:Lives_count, 1:Word_count, 2:Clock, 3:Text_label]
        GE = []
        for item in layout_return:
            GE.append(item)
        typed = ''  # return from binding event
        for i in range(self.nWord):
            # -------------------------Game Layout---------------------------
            print(f"i={i}")
            # Get random word to guess
            toType = word.select_random(game_list)

            # Update word count & word to guess
            GE[1].configure(text=f'Words :{i}/{self.nWord}')

            # text_label = tk_layout.add_text(root, toType, 0)  # Try another display
            tk_layout.update_text(self.root, GE[3], toType, 0)
            self.root.update()

            # -------------------------Start playing---------------------------
            # Start the countdown
            self.countdown(self.root, GE[2])
            # Create word_to guess instance

            WTG = self.word_to_guess(self.root, GE, toType)
            for y in range(len(toType)):
                typed = None
                print(f'totyped : {toType[y]}')
                while typed != toType[y]:
                    typed = keyboard.read_event().name
                    print(f"typed : {typed}")
                    if typed == "esc":
                        i = self.nWord  # End the game loop
                        y = len(toType)  # End the current word loop
                        self.layout_end(self.root, -1)
                    elif typed == toType[y]:
                        WTG.keys_pressed += typed
                        tk_layout.update_text(self.root, GE[3], WTG.word, len(WTG.keys_pressed))
